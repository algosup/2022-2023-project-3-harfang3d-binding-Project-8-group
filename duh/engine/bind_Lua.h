// FABgen output .h
// This file is automatically generated, do not modify manually!

#pragma once

#include <cstdint>

struct lua_State;

struct hg_lua_type_info {
	uint32_t type_tag;
	const char *c_type;
	const char *bound_name;

	bool (*check)(lua_State *L, int index);
	void (*to_c)(lua_State *L, int index, void *out);
	int (*from_c)(lua_State *L, void *obj, OwnershipPolicy policy);
};

// return a type info from its type tag
hg_lua_type_info *hg_lua_get_bound_type_info(uint32_t type_tag);
// return a type info from its type name
hg_lua_type_info *hg_lua_get_c_type_info(const char *type);
// returns the typetag of a userdata object on the stack, nullptr if not a Fabgen object
uint32_t hg_lua_get_wrapped_object_type_tag(lua_State *L, int idx);

// type API for bool
bool hg_lua_check_bool(lua_State *L, int idx);
void hg_lua_to_c_bool(lua_State *L, int idx, void *obj);
int hg_lua_from_c_bool(lua_State *L, void *obj, OwnershipPolicy);

// type API for char
bool hg_lua_check_char(lua_State *L, int idx);
void hg_lua_to_c_char(lua_State *L, int idx, void *obj);
int hg_lua_from_c_char(lua_State *L, void *obj, OwnershipPolicy);

// type API for short
bool hg_lua_check_short(lua_State *L, int idx);
void hg_lua_to_c_short(lua_State *L, int idx, void *obj);
int hg_lua_from_c_short(lua_State *L, void *obj, OwnershipPolicy);

// type API for int
bool hg_lua_check_int(lua_State *L, int idx);
void hg_lua_to_c_int(lua_State *L, int idx, void *obj);
int hg_lua_from_c_int(lua_State *L, void *obj, OwnershipPolicy);

// type API for long
bool hg_lua_check_long(lua_State *L, int idx);
void hg_lua_to_c_long(lua_State *L, int idx, void *obj);
int hg_lua_from_c_long(lua_State *L, void *obj, OwnershipPolicy);

// type API for int8_t
bool hg_lua_check_int8_t(lua_State *L, int idx);
void hg_lua_to_c_int8_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_int8_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for int16_t
bool hg_lua_check_int16_t(lua_State *L, int idx);
void hg_lua_to_c_int16_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_int16_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for int32_t
bool hg_lua_check_int32_t(lua_State *L, int idx);
void hg_lua_to_c_int32_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_int32_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for int64_t
bool hg_lua_check_int64_t(lua_State *L, int idx);
void hg_lua_to_c_int64_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_int64_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for char16_t
bool hg_lua_check_char16_t(lua_State *L, int idx);
void hg_lua_to_c_char16_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_char16_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for char32_t
bool hg_lua_check_char32_t(lua_State *L, int idx);
void hg_lua_to_c_char32_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_char32_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned char
bool hg_lua_check_unsigned_char(lua_State *L, int idx);
void hg_lua_to_c_unsigned_char(lua_State *L, int idx, void *obj);
int hg_lua_from_c_unsigned_char(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned short
bool hg_lua_check_unsigned_short(lua_State *L, int idx);
void hg_lua_to_c_unsigned_short(lua_State *L, int idx, void *obj);
int hg_lua_from_c_unsigned_short(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned int
bool hg_lua_check_unsigned_int(lua_State *L, int idx);
void hg_lua_to_c_unsigned_int(lua_State *L, int idx, void *obj);
int hg_lua_from_c_unsigned_int(lua_State *L, void *obj, OwnershipPolicy);

// type API for unsigned long
bool hg_lua_check_unsigned_long(lua_State *L, int idx);
void hg_lua_to_c_unsigned_long(lua_State *L, int idx, void *obj);
int hg_lua_from_c_unsigned_long(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint8_t
bool hg_lua_check_uint8_t(lua_State *L, int idx);
void hg_lua_to_c_uint8_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_uint8_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint16_t
bool hg_lua_check_uint16_t(lua_State *L, int idx);
void hg_lua_to_c_uint16_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_uint16_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint32_t
bool hg_lua_check_uint32_t(lua_State *L, int idx);
void hg_lua_to_c_uint32_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_uint32_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for uint64_t
bool hg_lua_check_uint64_t(lua_State *L, int idx);
void hg_lua_to_c_uint64_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_uint64_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for intptr_t
bool hg_lua_check_intptr_t(lua_State *L, int idx);
void hg_lua_to_c_intptr_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_intptr_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for size_t
bool hg_lua_check_size_t(lua_State *L, int idx);
void hg_lua_to_c_size_t(lua_State *L, int idx, void *obj);
int hg_lua_from_c_size_t(lua_State *L, void *obj, OwnershipPolicy);

// type API for float
bool hg_lua_check_float(lua_State *L, int idx);
void hg_lua_to_c_float(lua_State *L, int idx, void *obj);
int hg_lua_from_c_float(lua_State *L, void *obj, OwnershipPolicy);

// type API for double
bool hg_lua_check_double(lua_State *L, int idx);
void hg_lua_to_c_double(lua_State *L, int idx, void *obj);
int hg_lua_from_c_double(lua_State *L, void *obj, OwnershipPolicy);

// type API for const char *
struct storage_const_char_ptr;
bool hg_lua_check_const_char_ptr(lua_State *L, int idx);
void hg_lua_to_c_const_char_ptr(lua_State *L, int idx, void *obj, storage_const_char_ptr &storage);
int hg_lua_from_c_const_char_ptr(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::string
bool hg_lua_check_string(lua_State *L, int idx);
void hg_lua_to_c_string(lua_State *L, int idx, void *obj);
int hg_lua_from_c_string(lua_State *L, void *obj, OwnershipPolicy);

// type API for void *
bool hg_lua_check_VoidPointer(lua_State *L, int idx);
void hg_lua_to_c_VoidPointer(lua_State *L, int idx, void *obj);
int hg_lua_from_c_VoidPointer(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<void>
bool hg_lua_check_FutureVoid(lua_State *L, int idx);
void hg_lua_to_c_FutureVoid(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureVoid(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<bool>
bool hg_lua_check_FutureBool(lua_State *L, int idx);
void hg_lua_to_c_FutureBool(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureBool(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<int>
bool hg_lua_check_FutureInt(lua_State *L, int idx);
void hg_lua_to_c_FutureInt(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureInt(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<float>
bool hg_lua_check_FutureFloat(lua_State *L, int idx);
void hg_lua_to_c_FutureFloat(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureFloat(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<uint32_t>
bool hg_lua_check_FutureUInt(lua_State *L, int idx);
void hg_lua_to_c_FutureUInt(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureUInt(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<size_t>
bool hg_lua_check_FutureSize(lua_State *L, int idx);
void hg_lua_to_c_FutureSize(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureSize(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfChar
bool hg_lua_check_LuaTableOfChar(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfChar(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfChar(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<char>
bool hg_lua_check_CharList(lua_State *L, int idx);
void hg_lua_to_c_CharList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_CharList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfInt
bool hg_lua_check_LuaTableOfInt(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfInt(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfInt(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<int>
bool hg_lua_check_IntList(lua_State *L, int idx);
void hg_lua_to_c_IntList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_IntList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfInt8_T
bool hg_lua_check_LuaTableOfInt8_T(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfInt8_T(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfInt8_T(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<int8_t>
bool hg_lua_check_Int8_TList(lua_State *L, int idx);
void hg_lua_to_c_Int8_TList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Int8_TList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfInt16_T
bool hg_lua_check_LuaTableOfInt16_T(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfInt16_T(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfInt16_T(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<int16_t>
bool hg_lua_check_Int16_TList(lua_State *L, int idx);
void hg_lua_to_c_Int16_TList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Int16_TList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfInt32_T
bool hg_lua_check_LuaTableOfInt32_T(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfInt32_T(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfInt32_T(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<int32_t>
bool hg_lua_check_Int32_TList(lua_State *L, int idx);
void hg_lua_to_c_Int32_TList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Int32_TList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfInt64_T
bool hg_lua_check_LuaTableOfInt64_T(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfInt64_T(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfInt64_T(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<int64_t>
bool hg_lua_check_Int64_TList(lua_State *L, int idx);
void hg_lua_to_c_Int64_TList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Int64_TList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfUint8_T
bool hg_lua_check_LuaTableOfUint8_T(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfUint8_T(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfUint8_T(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<uint8_t>
bool hg_lua_check_Uint8_TList(lua_State *L, int idx);
void hg_lua_to_c_Uint8_TList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Uint8_TList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfUint16_T
bool hg_lua_check_LuaTableOfUint16_T(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfUint16_T(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfUint16_T(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<uint16_t>
bool hg_lua_check_Uint16_TList(lua_State *L, int idx);
void hg_lua_to_c_Uint16_TList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Uint16_TList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfUnsigned_Int
bool hg_lua_check_LuaTableOfUnsigned_Int(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfUnsigned_Int(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfUnsigned_Int(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<uint32_t>
bool hg_lua_check_Unsigned_IntList(lua_State *L, int idx);
void hg_lua_to_c_Unsigned_IntList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Unsigned_IntList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfUint64_T
bool hg_lua_check_LuaTableOfUint64_T(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfUint64_T(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfUint64_T(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<uint64_t>
bool hg_lua_check_Uint64_TList(lua_State *L, int idx);
void hg_lua_to_c_Uint64_TList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Uint64_TList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfFloat
bool hg_lua_check_LuaTableOfFloat(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfFloat(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfFloat(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<float>
bool hg_lua_check_FloatList(lua_State *L, int idx);
void hg_lua_to_c_FloatList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FloatList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfDouble
bool hg_lua_check_LuaTableOfDouble(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfDouble(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfDouble(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<double>
bool hg_lua_check_DoubleList(lua_State *L, int idx);
void hg_lua_to_c_DoubleList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_DoubleList(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfString
bool hg_lua_check_LuaTableOfString(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfString(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfString(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<std::string>
bool hg_lua_check_StringList(lua_State *L, int idx);
void hg_lua_to_c_StringList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_StringList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::BinaryData
bool hg_lua_check_BinaryData(lua_State *L, int idx);
void hg_lua_to_c_BinaryData(lua_State *L, int idx, void *obj);
int hg_lua_from_c_BinaryData(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::time_ns>
bool hg_lua_check_FutureTime(lua_State *L, int idx);
void hg_lua_to_c_FutureTime(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureTime(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Vector3
bool hg_lua_check_Vector3(lua_State *L, int idx);
void hg_lua_to_c_Vector3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Vector3(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Vector4
bool hg_lua_check_Vector4(lua_State *L, int idx);
void hg_lua_to_c_Vector4(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Vector4(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Matrix3
bool hg_lua_check_Matrix3(lua_State *L, int idx);
void hg_lua_to_c_Matrix3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Matrix3(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Matrix4
bool hg_lua_check_Matrix4(lua_State *L, int idx);
void hg_lua_to_c_Matrix4(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Matrix4(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Matrix44
bool hg_lua_check_Matrix44(lua_State *L, int idx);
void hg_lua_to_c_Matrix44(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Matrix44(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Quaternion
bool hg_lua_check_Quaternion(lua_State *L, int idx);
void hg_lua_to_c_Quaternion(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Quaternion(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MinMax
bool hg_lua_check_MinMax(lua_State *L, int idx);
void hg_lua_to_c_MinMax(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MinMax(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::tVector2<float>
bool hg_lua_check_Vector2(lua_State *L, int idx);
void hg_lua_to_c_Vector2(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Vector2(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::tVector2<int>
bool hg_lua_check_IntVector2(lua_State *L, int idx);
void hg_lua_to_c_IntVector2(lua_State *L, int idx, void *obj);
int hg_lua_from_c_IntVector2(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Rect<float>
bool hg_lua_check_Rect(lua_State *L, int idx);
void hg_lua_to_c_Rect(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Rect(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Rect<int>
bool hg_lua_check_IntRect(lua_State *L, int idx);
void hg_lua_to_c_IntRect(lua_State *L, int idx, void *obj);
int hg_lua_from_c_IntRect(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Plane
bool hg_lua_check_Plane(lua_State *L, int idx);
void hg_lua_to_c_Plane(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Plane(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::tVector2<float>>
bool hg_lua_check_FutureVector2(lua_State *L, int idx);
void hg_lua_to_c_FutureVector2(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureVector2(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::tVector2<int>>
bool hg_lua_check_FutureIntVector2(lua_State *L, int idx);
void hg_lua_to_c_FutureIntVector2(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureIntVector2(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Vector3>
bool hg_lua_check_FutureVector3(lua_State *L, int idx);
void hg_lua_to_c_FutureVector3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureVector3(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Vector4>
bool hg_lua_check_FutureVector4(lua_State *L, int idx);
void hg_lua_to_c_FutureVector4(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureVector4(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Matrix3>
bool hg_lua_check_FutureMatrix3(lua_State *L, int idx);
void hg_lua_to_c_FutureMatrix3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureMatrix3(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Matrix4>
bool hg_lua_check_FutureMatrix4(lua_State *L, int idx);
void hg_lua_to_c_FutureMatrix4(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureMatrix4(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Matrix44>
bool hg_lua_check_FutureMatrix44(lua_State *L, int idx);
void hg_lua_to_c_FutureMatrix44(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureMatrix44(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Rect<float>>
bool hg_lua_check_FutureFloatRect(lua_State *L, int idx);
void hg_lua_to_c_FutureFloatRect(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureFloatRect(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Rect<int>>
bool hg_lua_check_FutureIntRect(lua_State *L, int idx);
void hg_lua_to_c_FutureIntRect(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureIntRect(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfVector2
bool hg_lua_check_LuaTableOfVector2(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfVector2(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfVector2(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::tVector2<float>>
bool hg_lua_check_Vector2List(lua_State *L, int idx);
void hg_lua_to_c_Vector2List(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Vector2List(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfIntvector2
bool hg_lua_check_LuaTableOfIntvector2(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfIntvector2(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfIntvector2(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::tVector2<int>>
bool hg_lua_check_Intvector2List(lua_State *L, int idx);
void hg_lua_to_c_Intvector2List(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Intvector2List(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfVector3
bool hg_lua_check_LuaTableOfVector3(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfVector3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfVector3(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::Vector3>
bool hg_lua_check_Vector3List(lua_State *L, int idx);
void hg_lua_to_c_Vector3List(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Vector3List(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfVector4
bool hg_lua_check_LuaTableOfVector4(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfVector4(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfVector4(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::Vector4>
bool hg_lua_check_Vector4List(lua_State *L, int idx);
void hg_lua_to_c_Vector4List(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Vector4List(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfMatrix3
bool hg_lua_check_LuaTableOfMatrix3(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfMatrix3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfMatrix3(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::Matrix3>
bool hg_lua_check_Matrix3List(lua_State *L, int idx);
void hg_lua_to_c_Matrix3List(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Matrix3List(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfMatrix4
bool hg_lua_check_LuaTableOfMatrix4(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfMatrix4(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfMatrix4(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::Matrix4>
bool hg_lua_check_Matrix4List(lua_State *L, int idx);
void hg_lua_to_c_Matrix4List(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Matrix4List(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfMatrix44
bool hg_lua_check_LuaTableOfMatrix44(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfMatrix44(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfMatrix44(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::Matrix44>
bool hg_lua_check_Matrix44List(lua_State *L, int idx);
void hg_lua_to_c_Matrix44List(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Matrix44List(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Frustum
bool hg_lua_check_Frustum(lua_State *L, int idx);
void hg_lua_to_c_Frustum(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Frustum(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::FrustumPlanes
bool hg_lua_check_FrustumPlanes(lua_State *L, int idx);
void hg_lua_to_c_FrustumPlanes(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FrustumPlanes(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Surface
bool hg_lua_check_Surface(lua_State *L, int idx);
void hg_lua_to_c_Surface(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Surface(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MonitorMode
bool hg_lua_check_MonitorMode(lua_State *L, int idx);
void hg_lua_to_c_MonitorMode(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MonitorMode(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfMonitormode
bool hg_lua_check_LuaTableOfMonitormode(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfMonitormode(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfMonitormode(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::MonitorMode>
bool hg_lua_check_MonitormodeList(lua_State *L, int idx);
void hg_lua_to_c_MonitormodeList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MonitormodeList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Monitor
bool hg_lua_check_Monitor(lua_State *L, int idx);
void hg_lua_to_c_Monitor(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Monitor(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfMonitor
bool hg_lua_check_LuaTableOfMonitor(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfMonitor(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfMonitor(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::Monitor>
bool hg_lua_check_MonitorList(lua_State *L, int idx);
void hg_lua_to_c_MonitorList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MonitorList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Window
bool hg_lua_check_Window(lua_State *L, int idx);
void hg_lua_to_c_Window(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Window(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Window>
bool hg_lua_check_FutureWindow(lua_State *L, int idx);
void hg_lua_to_c_FutureWindow(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureWindow(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::Surface>
bool hg_lua_check_FutureSurface(lua_State *L, int idx);
void hg_lua_to_c_FutureSurface(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureSurface(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Color
bool hg_lua_check_Color(lua_State *L, int idx);
void hg_lua_to_c_Color(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Color(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfColor
bool hg_lua_check_LuaTableOfColor(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfColor(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfColor(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::Color>
bool hg_lua_check_ColorList(lua_State *L, int idx);
void hg_lua_to_c_ColorList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ColorList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::FontEngine
bool hg_lua_check_FontEngine(lua_State *L, int idx);
void hg_lua_to_c_FontEngine(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FontEngine(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Picture
bool hg_lua_check_Picture_nobind(lua_State *L, int idx);
void hg_lua_to_c_Picture_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Picture_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Picture>
bool hg_lua_check_Picture(lua_State *L, int idx);
void hg_lua_to_c_Picture(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Picture(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::DocumentReader
bool hg_lua_check_DocumentReader_nobind(lua_State *L, int idx);
void hg_lua_to_c_DocumentReader_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_DocumentReader_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::DocumentReader>
bool hg_lua_check_DocumentReader(lua_State *L, int idx);
void hg_lua_to_c_DocumentReader(lua_State *L, int idx, void *obj);
int hg_lua_from_c_DocumentReader(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::DocumentWriter
bool hg_lua_check_DocumentWriter_nobind(lua_State *L, int idx);
void hg_lua_to_c_DocumentWriter_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_DocumentWriter_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::DocumentWriter>
bool hg_lua_check_DocumentWriter(lua_State *L, int idx);
void hg_lua_to_c_DocumentWriter(lua_State *L, int idx, void *obj);
int hg_lua_from_c_DocumentWriter(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::FileDriver
bool hg_lua_check_FileDriver_nobind(lua_State *L, int idx);
void hg_lua_to_c_FileDriver_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FileDriver_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::FileHandle
bool hg_lua_check_FileHandle_nobind(lua_State *L, int idx);
void hg_lua_to_c_FileHandle_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FileHandle_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::FileDriver>
bool hg_lua_check_FileDriver(lua_State *L, int idx);
void hg_lua_to_c_FileDriver(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FileDriver(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::FileHandle>
bool hg_lua_check_FileHandle(lua_State *L, int idx);
void hg_lua_to_c_FileHandle(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FileHandle(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::StdFileDriver
bool hg_lua_check_StdFileDriver_nobind(lua_State *L, int idx);
void hg_lua_to_c_StdFileDriver_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_StdFileDriver_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::StdFileDriver>
bool hg_lua_check_StdFileDriver(lua_State *L, int idx);
void hg_lua_to_c_StdFileDriver(lua_State *L, int idx, void *obj);
int hg_lua_from_c_StdFileDriver(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ZipFileDriver
bool hg_lua_check_ZipFileDriver_nobind(lua_State *L, int idx);
void hg_lua_to_c_ZipFileDriver_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ZipFileDriver_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::ZipFileDriver>
bool hg_lua_check_ZipFileDriver(lua_State *L, int idx);
void hg_lua_to_c_ZipFileDriver(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ZipFileDriver(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::BufferFileDriver
bool hg_lua_check_BufferFileDriver_nobind(lua_State *L, int idx);
void hg_lua_to_c_BufferFileDriver_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_BufferFileDriver_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::BufferFileDriver>
bool hg_lua_check_BufferFileDriver(lua_State *L, int idx);
void hg_lua_to_c_BufferFileDriver(lua_State *L, int idx, void *obj);
int hg_lua_from_c_BufferFileDriver(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Filesystem
bool hg_lua_check_Filesystem(lua_State *L, int idx);
void hg_lua_to_c_Filesystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Filesystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::TypeValue
bool hg_lua_check_TypeValue(lua_State *L, int idx);
void hg_lua_to_c_TypeValue(lua_State *L, int idx, void *obj);
int hg_lua_from_c_TypeValue(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfTypevalue
bool hg_lua_check_LuaTableOfTypevalue(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfTypevalue(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfTypevalue(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::TypeValue>
bool hg_lua_check_TypevalueList(lua_State *L, int idx);
void hg_lua_to_c_TypevalueList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_TypevalueList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Shader
bool hg_lua_check_Shader_nobind(lua_State *L, int idx);
void hg_lua_to_c_Shader_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Shader_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Shader>
bool hg_lua_check_Shader(lua_State *L, int idx);
void hg_lua_to_c_Shader(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Shader(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ShaderVariable
bool hg_lua_check_ShaderVariable(lua_State *L, int idx);
void hg_lua_to_c_ShaderVariable(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ShaderVariable(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::TextureUnitConfig
bool hg_lua_check_TextureUnitConfig(lua_State *L, int idx);
void hg_lua_to_c_TextureUnitConfig(lua_State *L, int idx, void *obj);
int hg_lua_from_c_TextureUnitConfig(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ShaderValue
bool hg_lua_check_ShaderValue(lua_State *L, int idx);
void hg_lua_to_c_ShaderValue(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ShaderValue(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MaterialValue
bool hg_lua_check_MaterialValue(lua_State *L, int idx);
void hg_lua_to_c_MaterialValue(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MaterialValue(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Material
bool hg_lua_check_Material_nobind(lua_State *L, int idx);
void hg_lua_to_c_Material_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Material_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Material>
bool hg_lua_check_Material(lua_State *L, int idx);
void hg_lua_to_c_Material(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Material(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Geometry
bool hg_lua_check_Geometry_nobind(lua_State *L, int idx);
void hg_lua_to_c_Geometry_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Geometry_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Geometry>
bool hg_lua_check_Geometry(lua_State *L, int idx);
void hg_lua_to_c_Geometry(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Geometry(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfGeometry
bool hg_lua_check_LuaTableOfGeometry(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfGeometry(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfGeometry(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<std::shared_ptr<hg::Geometry>>
bool hg_lua_check_GeometryList(lua_State *L, int idx);
void hg_lua_to_c_GeometryList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GeometryList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::VertexLayout::Attribute
bool hg_lua_check_VertexLayoutAttribute(lua_State *L, int idx);
void hg_lua_to_c_VertexLayoutAttribute(lua_State *L, int idx, void *obj);
int hg_lua_from_c_VertexLayoutAttribute(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::VertexLayout
bool hg_lua_check_VertexLayout(lua_State *L, int idx);
void hg_lua_to_c_VertexLayout(lua_State *L, int idx, void *obj);
int hg_lua_from_c_VertexLayout(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::GpuBuffer
bool hg_lua_check_Buffer_nobind(lua_State *L, int idx);
void hg_lua_to_c_Buffer_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Buffer_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::GpuBuffer>
bool hg_lua_check_GpuBuffer(lua_State *L, int idx);
void hg_lua_to_c_GpuBuffer(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuBuffer(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::GpuResource
bool hg_lua_check_GpuResource_nobind(lua_State *L, int idx);
void hg_lua_to_c_GpuResource_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuResource_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::GpuResource>
bool hg_lua_check_GpuResource(lua_State *L, int idx);
void hg_lua_to_c_GpuResource(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuResource(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Texture
bool hg_lua_check_Texture_nobind(lua_State *L, int idx);
void hg_lua_to_c_Texture_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Texture_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Texture>
bool hg_lua_check_Texture(lua_State *L, int idx);
void hg_lua_to_c_Texture(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Texture(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfTexture
bool hg_lua_check_LuaTableOfTexture(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfTexture(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfTexture(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<std::shared_ptr<hg::Texture>>
bool hg_lua_check_TextureList(lua_State *L, int idx);
void hg_lua_to_c_TextureList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_TextureList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderTarget
bool hg_lua_check_RenderTarget_nobind(lua_State *L, int idx);
void hg_lua_to_c_RenderTarget_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderTarget_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RenderTarget>
bool hg_lua_check_RenderTarget(lua_State *L, int idx);
void hg_lua_to_c_RenderTarget(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderTarget(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<std::shared_ptr<hg::RenderTarget>>
bool hg_lua_check_FutureRenderTarget(lua_State *L, int idx);
void hg_lua_to_c_FutureRenderTarget(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureRenderTarget(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::GpuHardwareInfo
bool hg_lua_check_GpuHardwareInfo(lua_State *L, int idx);
void hg_lua_to_c_GpuHardwareInfo(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuHardwareInfo(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::GpuShader
bool hg_lua_check_GpuShader_nobind(lua_State *L, int idx);
void hg_lua_to_c_GpuShader_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuShader_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::GpuShader>
bool hg_lua_check_GpuShader(lua_State *L, int idx);
void hg_lua_to_c_GpuShader(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuShader(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<std::shared_ptr<hg::GpuShader>>
bool hg_lua_check_FutureGpuShader(lua_State *L, int idx);
void hg_lua_to_c_FutureGpuShader(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureGpuShader(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::GpuShaderValue
bool hg_lua_check_GpuShaderValue(lua_State *L, int idx);
void hg_lua_to_c_GpuShaderValue(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuShaderValue(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::GpuShaderVariable
bool hg_lua_check_GpuShaderVariable(lua_State *L, int idx);
void hg_lua_to_c_GpuShaderVariable(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GpuShaderVariable(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ResourceCache<hg::Texture>
bool hg_lua_check_TextureCache(lua_State *L, int idx);
void hg_lua_to_c_TextureCache(lua_State *L, int idx, void *obj);
int hg_lua_from_c_TextureCache(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ResourceCache<hg::GpuShader>
bool hg_lua_check_ShaderCache(lua_State *L, int idx);
void hg_lua_to_c_ShaderCache(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ShaderCache(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Renderer
bool hg_lua_check_Renderer_nobind(lua_State *L, int idx);
void hg_lua_to_c_Renderer_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Renderer_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Renderer>
bool hg_lua_check_Renderer(lua_State *L, int idx);
void hg_lua_to_c_Renderer(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Renderer(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RendererAsync
bool hg_lua_check_RendererAsync_nobind(lua_State *L, int idx);
void hg_lua_to_c_RendererAsync_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RendererAsync_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RendererAsync>
bool hg_lua_check_RendererAsync(lua_State *L, int idx);
void hg_lua_to_c_RendererAsync(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RendererAsync(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderSystem
bool hg_lua_check_RenderSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_RenderSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RenderSystem>
bool hg_lua_check_RenderSystem(lua_State *L, int idx);
void hg_lua_to_c_RenderSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SurfaceShader
bool hg_lua_check_SurfaceShader_nobind(lua_State *L, int idx);
void hg_lua_to_c_SurfaceShader_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SurfaceShader_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SurfaceShader>
bool hg_lua_check_SurfaceShader(lua_State *L, int idx);
void hg_lua_to_c_SurfaceShader(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SurfaceShader(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderMaterial
bool hg_lua_check_RenderMaterial_nobind(lua_State *L, int idx);
void hg_lua_to_c_RenderMaterial_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderMaterial_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RenderMaterial>
bool hg_lua_check_RenderMaterial(lua_State *L, int idx);
void hg_lua_to_c_RenderMaterial(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderMaterial(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderGeometry
bool hg_lua_check_RenderGeometry_nobind(lua_State *L, int idx);
void hg_lua_to_c_RenderGeometry_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderGeometry_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RenderGeometry>
bool hg_lua_check_RenderGeometry(lua_State *L, int idx);
void hg_lua_to_c_RenderGeometry(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderGeometry(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderStatistics
bool hg_lua_check_RenderStatistics(lua_State *L, int idx);
void hg_lua_to_c_RenderStatistics(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderStatistics(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ViewState
bool hg_lua_check_ViewState(lua_State *L, int idx);
void hg_lua_to_c_ViewState(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ViewState(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::RenderTechnique>
bool hg_lua_check_FutureRenderTechnique(lua_State *L, int idx);
void hg_lua_to_c_FutureRenderTechnique(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureRenderTechnique(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderSystemAsync
bool hg_lua_check_RenderSystemAsync_nobind(lua_State *L, int idx);
void hg_lua_to_c_RenderSystemAsync_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderSystemAsync_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RenderSystemAsync>
bool hg_lua_check_RenderSystemAsync(lua_State *L, int idx);
void hg_lua_to_c_RenderSystemAsync(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderSystemAsync(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RasterFont
bool hg_lua_check_RasterFont_nobind(lua_State *L, int idx);
void hg_lua_to_c_RasterFont_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RasterFont_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RasterFont>
bool hg_lua_check_RasterFont(lua_State *L, int idx);
void hg_lua_to_c_RasterFont(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RasterFont(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SimpleGraphicEngine
bool hg_lua_check_SimpleGraphicEngine(lua_State *L, int idx);
void hg_lua_to_c_SimpleGraphicEngine(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SimpleGraphicEngine(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::IsoSurface
bool hg_lua_check_IsoSurface_nobind(lua_State *L, int idx);
void hg_lua_to_c_IsoSurface_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_IsoSurface_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::IsoSurface>
bool hg_lua_check_IsoSurface(lua_State *L, int idx);
void hg_lua_to_c_IsoSurface(lua_State *L, int idx, void *obj);
int hg_lua_from_c_IsoSurface(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::FrameRenderer
bool hg_lua_check_FrameRenderer_nobind(lua_State *L, int idx);
void hg_lua_to_c_FrameRenderer_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FrameRenderer_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::FrameRenderer>
bool hg_lua_check_FrameRenderer(lua_State *L, int idx);
void hg_lua_to_c_FrameRenderer(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FrameRenderer(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AudioFormat
bool hg_lua_check_AudioFormat(lua_State *L, int idx);
void hg_lua_to_c_AudioFormat(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AudioFormat(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AudioData
bool hg_lua_check_AudioData_nobind(lua_State *L, int idx);
void hg_lua_to_c_AudioData_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AudioData_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::AudioData>
bool hg_lua_check_AudioData(lua_State *L, int idx);
void hg_lua_to_c_AudioData(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AudioData(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AudioIO
bool hg_lua_check_AudioIO(lua_State *L, int idx);
void hg_lua_to_c_AudioIO(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AudioIO(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MixerChannelState
bool hg_lua_check_MixerChannelState(lua_State *L, int idx);
void hg_lua_to_c_MixerChannelState(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MixerChannelState(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MixerChannelLocation
bool hg_lua_check_MixerChannelLocation(lua_State *L, int idx);
void hg_lua_to_c_MixerChannelLocation(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MixerChannelLocation(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Sound
bool hg_lua_check_Sound_nobind(lua_State *L, int idx);
void hg_lua_to_c_Sound_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Sound_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Sound>
bool hg_lua_check_Sound(lua_State *L, int idx);
void hg_lua_to_c_Sound(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Sound(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Mixer
bool hg_lua_check_Mixer_nobind(lua_State *L, int idx);
void hg_lua_to_c_Mixer_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Mixer_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Mixer>
bool hg_lua_check_Mixer(lua_State *L, int idx);
void hg_lua_to_c_Mixer(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Mixer(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MixerAsync
bool hg_lua_check_MixerAsync_nobind(lua_State *L, int idx);
void hg_lua_to_c_MixerAsync_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MixerAsync_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::MixerAsync>
bool hg_lua_check_MixerAsync(lua_State *L, int idx);
void hg_lua_to_c_MixerAsync(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MixerAsync(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::MixerChannel>
bool hg_lua_check_FutureMixerChannel(lua_State *L, int idx);
void hg_lua_to_c_FutureMixerChannel(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureMixerChannel(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::MixerChannelState>
bool hg_lua_check_FutureMixerChannelState(lua_State *L, int idx);
void hg_lua_to_c_FutureMixerChannelState(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureMixerChannelState(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::MixerChannelLocation>
bool hg_lua_check_FutureMixerChannelLocation(lua_State *L, int idx);
void hg_lua_to_c_FutureMixerChannelLocation(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureMixerChannelLocation(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::future<hg::MixerPlayState>
bool hg_lua_check_FutureMixerPlayState(lua_State *L, int idx);
void hg_lua_to_c_FutureMixerPlayState(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FutureMixerPlayState(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Movie
bool hg_lua_check_Movie_nobind(lua_State *L, int idx);
void hg_lua_to_c_Movie_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Movie_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Movie>
bool hg_lua_check_Movie(lua_State *L, int idx);
void hg_lua_to_c_Movie(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Movie(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Node
bool hg_lua_check_Node_nobind(lua_State *L, int idx);
void hg_lua_to_c_Node_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Node_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Node>
bool hg_lua_check_Node(lua_State *L, int idx);
void hg_lua_to_c_Node(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Node(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Scene
bool hg_lua_check_Scene_nobind(lua_State *L, int idx);
void hg_lua_to_c_Scene_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Scene_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Scene>
bool hg_lua_check_Scene(lua_State *L, int idx);
void hg_lua_to_c_Scene(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Scene(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SceneSystem
bool hg_lua_check_SceneSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_SceneSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SceneSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SceneSystem>
bool hg_lua_check_SceneSystem(lua_State *L, int idx);
void hg_lua_to_c_SceneSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SceneSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Group
bool hg_lua_check_Group_nobind(lua_State *L, int idx);
void hg_lua_to_c_Group_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Group_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Group>
bool hg_lua_check_Group(lua_State *L, int idx);
void hg_lua_to_c_Group(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Group(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Component
bool hg_lua_check_Component_nobind(lua_State *L, int idx);
void hg_lua_to_c_Component_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Component_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Component>
bool hg_lua_check_Component(lua_State *L, int idx);
void hg_lua_to_c_Component(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Component(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Instance
bool hg_lua_check_Instance_nobind(lua_State *L, int idx);
void hg_lua_to_c_Instance_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Instance_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Instance>
bool hg_lua_check_Instance(lua_State *L, int idx);
void hg_lua_to_c_Instance(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Instance(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Metadata
bool hg_lua_check_Metadata_nobind(lua_State *L, int idx);
void hg_lua_to_c_Metadata_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Metadata_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Metadata>
bool hg_lua_check_Metadata(lua_State *L, int idx);
void hg_lua_to_c_Metadata(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Metadata(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Target
bool hg_lua_check_Target_nobind(lua_State *L, int idx);
void hg_lua_to_c_Target_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Target_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Target>
bool hg_lua_check_Target(lua_State *L, int idx);
void hg_lua_to_c_Target(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Target(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Environment
bool hg_lua_check_Environment_nobind(lua_State *L, int idx);
void hg_lua_to_c_Environment_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Environment_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Environment>
bool hg_lua_check_Environment(lua_State *L, int idx);
void hg_lua_to_c_Environment(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Environment(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SimpleGraphicSceneOverlay
bool hg_lua_check_SimpleGraphicSceneOverlay_nobind(lua_State *L, int idx);
void hg_lua_to_c_SimpleGraphicSceneOverlay_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SimpleGraphicSceneOverlay_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SimpleGraphicSceneOverlay>
bool hg_lua_check_SimpleGraphicSceneOverlay(lua_State *L, int idx);
void hg_lua_to_c_SimpleGraphicSceneOverlay(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SimpleGraphicSceneOverlay(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Transform
bool hg_lua_check_Transform_nobind(lua_State *L, int idx);
void hg_lua_to_c_Transform_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Transform_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Transform>
bool hg_lua_check_Transform(lua_State *L, int idx);
void hg_lua_to_c_Transform(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Transform(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Camera
bool hg_lua_check_Camera_nobind(lua_State *L, int idx);
void hg_lua_to_c_Camera_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Camera_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Camera>
bool hg_lua_check_Camera(lua_State *L, int idx);
void hg_lua_to_c_Camera(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Camera(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Object
bool hg_lua_check_Object_nobind(lua_State *L, int idx);
void hg_lua_to_c_Object_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Object_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Object>
bool hg_lua_check_Object(lua_State *L, int idx);
void hg_lua_to_c_Object(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Object(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Light
bool hg_lua_check_Light_nobind(lua_State *L, int idx);
void hg_lua_to_c_Light_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Light_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Light>
bool hg_lua_check_Light(lua_State *L, int idx);
void hg_lua_to_c_Light(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Light(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Decorator
bool hg_lua_check_Decorator_nobind(lua_State *L, int idx);
void hg_lua_to_c_Decorator_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Decorator_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Decorator>
bool hg_lua_check_Decorator(lua_State *L, int idx);
void hg_lua_to_c_Decorator(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Decorator(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RigidBody
bool hg_lua_check_RigidBody_nobind(lua_State *L, int idx);
void hg_lua_to_c_RigidBody_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RigidBody_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RigidBody>
bool hg_lua_check_RigidBody(lua_State *L, int idx);
void hg_lua_to_c_RigidBody(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RigidBody(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Collision
bool hg_lua_check_Collision_nobind(lua_State *L, int idx);
void hg_lua_to_c_Collision_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Collision_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Collision>
bool hg_lua_check_Collision(lua_State *L, int idx);
void hg_lua_to_c_Collision(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Collision(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::BoxCollision
bool hg_lua_check_BoxCollision_nobind(lua_State *L, int idx);
void hg_lua_to_c_BoxCollision_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_BoxCollision_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::BoxCollision>
bool hg_lua_check_BoxCollision(lua_State *L, int idx);
void hg_lua_to_c_BoxCollision(lua_State *L, int idx, void *obj);
int hg_lua_from_c_BoxCollision(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MeshCollision
bool hg_lua_check_MeshCollision_nobind(lua_State *L, int idx);
void hg_lua_to_c_MeshCollision_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MeshCollision_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::MeshCollision>
bool hg_lua_check_MeshCollision(lua_State *L, int idx);
void hg_lua_to_c_MeshCollision(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MeshCollision(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SphereCollision
bool hg_lua_check_SphereCollision_nobind(lua_State *L, int idx);
void hg_lua_to_c_SphereCollision_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SphereCollision_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SphereCollision>
bool hg_lua_check_SphereCollision(lua_State *L, int idx);
void hg_lua_to_c_SphereCollision(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SphereCollision(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::CapsuleCollision
bool hg_lua_check_CapsuleCollision_nobind(lua_State *L, int idx);
void hg_lua_to_c_CapsuleCollision_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_CapsuleCollision_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::CapsuleCollision>
bool hg_lua_check_CapsuleCollision(lua_State *L, int idx);
void hg_lua_to_c_CapsuleCollision(lua_State *L, int idx, void *obj);
int hg_lua_from_c_CapsuleCollision(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ConvexCollision
bool hg_lua_check_ConvexCollision_nobind(lua_State *L, int idx);
void hg_lua_to_c_ConvexCollision_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ConvexCollision_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::ConvexCollision>
bool hg_lua_check_ConvexCollision(lua_State *L, int idx);
void hg_lua_to_c_ConvexCollision(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ConvexCollision(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::JointLimit
bool hg_lua_check_JointLimit(lua_State *L, int idx);
void hg_lua_to_c_JointLimit(lua_State *L, int idx, void *obj);
int hg_lua_from_c_JointLimit(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Joint
bool hg_lua_check_Joint_nobind(lua_State *L, int idx);
void hg_lua_to_c_Joint_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Joint_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Joint>
bool hg_lua_check_Joint(lua_State *L, int idx);
void hg_lua_to_c_Joint(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Joint(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SphericalJoint
bool hg_lua_check_SphericalJoint_nobind(lua_State *L, int idx);
void hg_lua_to_c_SphericalJoint_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SphericalJoint_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SphericalJoint>
bool hg_lua_check_SphericalJoint(lua_State *L, int idx);
void hg_lua_to_c_SphericalJoint(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SphericalJoint(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::D6Joint
bool hg_lua_check_D6Joint_nobind(lua_State *L, int idx);
void hg_lua_to_c_D6Joint_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_D6Joint_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::D6Joint>
bool hg_lua_check_D6Joint(lua_State *L, int idx);
void hg_lua_to_c_D6Joint(lua_State *L, int idx, void *obj);
int hg_lua_from_c_D6Joint(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Terrain
bool hg_lua_check_Terrain_nobind(lua_State *L, int idx);
void hg_lua_to_c_Terrain_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Terrain_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Terrain>
bool hg_lua_check_Terrain(lua_State *L, int idx);
void hg_lua_to_c_Terrain(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Terrain(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::PostProcessComponent
bool hg_lua_check_PostProcessComponent_nobind(lua_State *L, int idx);
void hg_lua_to_c_PostProcessComponent_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_PostProcessComponent_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::PostProcessComponent>
bool hg_lua_check_PostProcessComponent(lua_State *L, int idx);
void hg_lua_to_c_PostProcessComponent(lua_State *L, int idx, void *obj);
int hg_lua_from_c_PostProcessComponent(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SharpenPostProcess
bool hg_lua_check_SharpenPostProcess_nobind(lua_State *L, int idx);
void hg_lua_to_c_SharpenPostProcess_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SharpenPostProcess_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SharpenPostProcess>
bool hg_lua_check_SharpenPostProcess(lua_State *L, int idx);
void hg_lua_to_c_SharpenPostProcess(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SharpenPostProcess(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RadialBlurPostProcess
bool hg_lua_check_RadialBlurPostProcess_nobind(lua_State *L, int idx);
void hg_lua_to_c_RadialBlurPostProcess_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RadialBlurPostProcess_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RadialBlurPostProcess>
bool hg_lua_check_RadialBlurPostProcess(lua_State *L, int idx);
void hg_lua_to_c_RadialBlurPostProcess(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RadialBlurPostProcess(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ChromaticDispersionPostProcess
bool hg_lua_check_ChromaticDispersionPostProcess_nobind(lua_State *L, int idx);
void hg_lua_to_c_ChromaticDispersionPostProcess_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ChromaticDispersionPostProcess_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::ChromaticDispersionPostProcess>
bool hg_lua_check_ChromaticDispersionPostProcess(lua_State *L, int idx);
void hg_lua_to_c_ChromaticDispersionPostProcess(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ChromaticDispersionPostProcess(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::HSLPostProcess
bool hg_lua_check_HSLPostProcess_nobind(lua_State *L, int idx);
void hg_lua_to_c_HSLPostProcess_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_HSLPostProcess_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::HSLPostProcess>
bool hg_lua_check_HSLPostProcess(lua_State *L, int idx);
void hg_lua_to_c_HSLPostProcess(lua_State *L, int idx, void *obj);
int hg_lua_from_c_HSLPostProcess(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::MotionBlurPostProcess
bool hg_lua_check_MotionBlurPostProcess_nobind(lua_State *L, int idx);
void hg_lua_to_c_MotionBlurPostProcess_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MotionBlurPostProcess_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::MotionBlurPostProcess>
bool hg_lua_check_MotionBlurPostProcess(lua_State *L, int idx);
void hg_lua_to_c_MotionBlurPostProcess(lua_State *L, int idx, void *obj);
int hg_lua_from_c_MotionBlurPostProcess(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SAOPostProcess
bool hg_lua_check_SAOPostProcess_nobind(lua_State *L, int idx);
void hg_lua_to_c_SAOPostProcess_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SAOPostProcess_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SAOPostProcess>
bool hg_lua_check_SAOPostProcess(lua_State *L, int idx);
void hg_lua_to_c_SAOPostProcess(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SAOPostProcess(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::BloomPostProcess
bool hg_lua_check_BloomPostProcess_nobind(lua_State *L, int idx);
void hg_lua_to_c_BloomPostProcess_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_BloomPostProcess_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::BloomPostProcess>
bool hg_lua_check_BloomPostProcess(lua_State *L, int idx);
void hg_lua_to_c_BloomPostProcess(lua_State *L, int idx, void *obj);
int hg_lua_from_c_BloomPostProcess(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ScriptEngineEnv
bool hg_lua_check_ScriptEnv_nobind(lua_State *L, int idx);
void hg_lua_to_c_ScriptEnv_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ScriptEnv_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::ScriptEngineEnv>
bool hg_lua_check_ScriptEnv(lua_State *L, int idx);
void hg_lua_to_c_ScriptEnv(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ScriptEnv(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ScriptObject
bool hg_lua_check_ScriptObject(lua_State *L, int idx);
void hg_lua_to_c_ScriptObject(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ScriptObject(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Script
bool hg_lua_check_Script_nobind(lua_State *L, int idx);
void hg_lua_to_c_Script_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Script_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Script>
bool hg_lua_check_Script(lua_State *L, int idx);
void hg_lua_to_c_Script(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Script(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderScript
bool hg_lua_check_RenderScript_nobind(lua_State *L, int idx);
void hg_lua_to_c_RenderScript_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderScript_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RenderScript>
bool hg_lua_check_RenderScript(lua_State *L, int idx);
void hg_lua_to_c_RenderScript(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderScript(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::LogicScript
bool hg_lua_check_LogicScript_nobind(lua_State *L, int idx);
void hg_lua_to_c_LogicScript_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LogicScript_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::LogicScript>
bool hg_lua_check_LogicScript(lua_State *L, int idx);
void hg_lua_to_c_LogicScript(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LogicScript(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::NavigationPath
bool hg_lua_check_NavigationPath(lua_State *L, int idx);
void hg_lua_to_c_NavigationPath(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationPath(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::NavigationLayer
bool hg_lua_check_NavigationLayer(lua_State *L, int idx);
void hg_lua_to_c_NavigationLayer(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationLayer(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfNavigationlayer
bool hg_lua_check_LuaTableOfNavigationlayer(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfNavigationlayer(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfNavigationlayer(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::NavigationLayer>
bool hg_lua_check_NavigationlayerList(lua_State *L, int idx);
void hg_lua_to_c_NavigationlayerList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationlayerList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::NavigationConfig
bool hg_lua_check_NavigationConfig(lua_State *L, int idx);
void hg_lua_to_c_NavigationConfig(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationConfig(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::NavigationSystem
bool hg_lua_check_NavigationSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_NavigationSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::NavigationSystem>
bool hg_lua_check_NavigationSystem(lua_State *L, int idx);
void hg_lua_to_c_NavigationSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::NavigationGeometry
bool hg_lua_check_NavigationGeometry_nobind(lua_State *L, int idx);
void hg_lua_to_c_NavigationGeometry_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationGeometry_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::NavigationGeometry>
bool hg_lua_check_NavigationGeometry(lua_State *L, int idx);
void hg_lua_to_c_NavigationGeometry(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NavigationGeometry(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Navigation
bool hg_lua_check_Navigation_nobind(lua_State *L, int idx);
void hg_lua_to_c_Navigation_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Navigation_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Navigation>
bool hg_lua_check_Navigation(lua_State *L, int idx);
void hg_lua_to_c_Navigation(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Navigation(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfComponent
bool hg_lua_check_LuaTableOfComponent(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfComponent(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfComponent(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<std::shared_ptr<hg::Component>>
bool hg_lua_check_ComponentList(lua_State *L, int idx);
void hg_lua_to_c_ComponentList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ComponentList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ScriptSystem
bool hg_lua_check_ScriptSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_ScriptSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ScriptSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::ScriptSystem>
bool hg_lua_check_ScriptSystem(lua_State *L, int idx);
void hg_lua_to_c_ScriptSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ScriptSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::LuaSystem
bool hg_lua_check_LuaSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_LuaSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::LuaSystem>
bool hg_lua_check_LuaSystem(lua_State *L, int idx);
void hg_lua_to_c_LuaSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfNode
bool hg_lua_check_LuaTableOfNode(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfNode(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfNode(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<std::shared_ptr<hg::Node>>
bool hg_lua_check_NodeList(lua_State *L, int idx);
void hg_lua_to_c_NodeList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_NodeList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderableSystem
bool hg_lua_check_RenderableSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_RenderableSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderableSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::RenderableSystem>
bool hg_lua_check_RenderableSystem(lua_State *L, int idx);
void hg_lua_to_c_RenderableSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderableSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::TransformSystem
bool hg_lua_check_TransformSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_TransformSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_TransformSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::TransformSystem>
bool hg_lua_check_TransformSystem(lua_State *L, int idx);
void hg_lua_to_c_TransformSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_TransformSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::PhysicTrace
bool hg_lua_check_PhysicTrace(lua_State *L, int idx);
void hg_lua_to_c_PhysicTrace(lua_State *L, int idx, void *obj);
int hg_lua_from_c_PhysicTrace(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::PhysicSystem
bool hg_lua_check_PhysicSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_PhysicSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_PhysicSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::PhysicSystem>
bool hg_lua_check_PhysicSystem(lua_State *L, int idx);
void hg_lua_to_c_PhysicSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_PhysicSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::CollisionPair
bool hg_lua_check_CollisionPair(lua_State *L, int idx);
void hg_lua_to_c_CollisionPair(lua_State *L, int idx, void *obj);
int hg_lua_from_c_CollisionPair(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfCollisionpair
bool hg_lua_check_LuaTableOfCollisionpair(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfCollisionpair(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfCollisionpair(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<hg::CollisionPair>
bool hg_lua_check_CollisionpairList(lua_State *L, int idx);
void hg_lua_to_c_CollisionpairList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_CollisionpairList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::SceneBoundAnim
bool hg_lua_check_SceneBoundAnim_nobind(lua_State *L, int idx);
void hg_lua_to_c_SceneBoundAnim_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SceneBoundAnim_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::SceneBoundAnim>
bool hg_lua_check_SceneBoundAnim(lua_State *L, int idx);
void hg_lua_to_c_SceneBoundAnim(lua_State *L, int idx, void *obj);
int hg_lua_from_c_SceneBoundAnim(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AnimTrack
bool hg_lua_check_AnimTrack_nobind(lua_State *L, int idx);
void hg_lua_to_c_AnimTrack_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrack_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::AnimTrack>
bool hg_lua_check_AnimTrack(lua_State *L, int idx);
void hg_lua_to_c_AnimTrack(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrack(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AnimKey<float>
bool hg_lua_check_AnimKeyFloat(lua_State *L, int idx);
void hg_lua_to_c_AnimKeyFloat(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimKeyFloat(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AnimKey<hg::Vector3>
bool hg_lua_check_AnimKeyVector3(lua_State *L, int idx);
void hg_lua_to_c_AnimKeyVector3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimKeyVector3(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AnimTrackT<float>
bool hg_lua_check_AnimTrackFloat_nobind(lua_State *L, int idx);
void hg_lua_to_c_AnimTrackFloat_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrackFloat_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::AnimTrackT<float>>
bool hg_lua_check_AnimTrackFloat(lua_State *L, int idx);
void hg_lua_to_c_AnimTrackFloat(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrackFloat(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AnimTrackT<hg::Vector3>
bool hg_lua_check_AnimTrackVector3_nobind(lua_State *L, int idx);
void hg_lua_to_c_AnimTrackVector3_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrackVector3_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::AnimTrackT<hg::Vector3>>
bool hg_lua_check_AnimTrackVector3(lua_State *L, int idx);
void hg_lua_to_c_AnimTrackVector3(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrackVector3(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AnimTrackRotation
bool hg_lua_check_AnimTrackRotation_nobind(lua_State *L, int idx);
void hg_lua_to_c_AnimTrackRotation_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrackRotation_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::AnimTrackRotation>
bool hg_lua_check_AnimTrackRotation(lua_State *L, int idx);
void hg_lua_to_c_AnimTrackRotation(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTrackRotation(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Anim
bool hg_lua_check_Anim_nobind(lua_State *L, int idx);
void hg_lua_to_c_Anim_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Anim_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::Anim>
bool hg_lua_check_Anim(lua_State *L, int idx);
void hg_lua_to_c_Anim(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Anim(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::AnimTake
bool hg_lua_check_AnimTake_nobind(lua_State *L, int idx);
void hg_lua_to_c_AnimTake_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTake_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::AnimTake>
bool hg_lua_check_AnimTake(lua_State *L, int idx);
void hg_lua_to_c_AnimTake(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimTake(lua_State *L, void *obj, OwnershipPolicy);

// type API for LuaTableOfAnimtake
bool hg_lua_check_LuaTableOfAnimtake(lua_State *L, int idx);
void hg_lua_to_c_LuaTableOfAnimtake(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTableOfAnimtake(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<std::shared_ptr<hg::AnimTake>>
bool hg_lua_check_AnimtakeList(lua_State *L, int idx);
void hg_lua_to_c_AnimtakeList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_AnimtakeList(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::vector<std::shared_ptr<hg::Group>>
bool hg_lua_check_GroupList(lua_State *L, int idx);
void hg_lua_to_c_GroupList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_GroupList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::ScenePicking
bool hg_lua_check_ScenePicking(lua_State *L, int idx);
void hg_lua_to_c_ScenePicking(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ScenePicking(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::InputDevice
bool hg_lua_check_InputDevice_nobind(lua_State *L, int idx);
void hg_lua_to_c_InputDevice_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_InputDevice_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::InputDevice>
bool hg_lua_check_InputDevice(lua_State *L, int idx);
void hg_lua_to_c_InputDevice(lua_State *L, int idx, void *obj);
int hg_lua_from_c_InputDevice(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::InputSystem
bool hg_lua_check_InputSystem(lua_State *L, int idx);
void hg_lua_to_c_InputSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_InputSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::RenderWindow
bool hg_lua_check_RenderWindow(lua_State *L, int idx);
void hg_lua_to_c_RenderWindow(lua_State *L, int idx, void *obj);
int hg_lua_from_c_RenderWindow(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::Plus
bool hg_lua_check_Plus(lua_State *L, int idx);
void hg_lua_to_c_Plus(lua_State *L, int idx, void *obj);
int hg_lua_from_c_Plus(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::FPSController
bool hg_lua_check_FPSController(lua_State *L, int idx);
void hg_lua_to_c_FPSController(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FPSController(lua_State *L, void *obj, OwnershipPolicy);

// type API for ImFont
bool hg_lua_check_ImFont(lua_State *L, int idx);
void hg_lua_to_c_ImFont(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ImFont(lua_State *L, void *obj, OwnershipPolicy);

// type API for ImDrawList
bool hg_lua_check_ImDrawList(lua_State *L, int idx);
void hg_lua_to_c_ImDrawList(lua_State *L, int idx, void *obj);
int hg_lua_from_c_ImDrawList(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::LuaTaskHandle
bool hg_lua_check_LuaTaskHandle_nobind(lua_State *L, int idx);
void hg_lua_to_c_LuaTaskHandle_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTaskHandle_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::LuaTaskHandle>
bool hg_lua_check_LuaTaskHandle(lua_State *L, int idx);
void hg_lua_to_c_LuaTaskHandle(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTaskHandle(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::LuaTask
bool hg_lua_check_LuaTask_nobind(lua_State *L, int idx);
void hg_lua_to_c_LuaTask_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTask_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::LuaTask>
bool hg_lua_check_LuaTask(lua_State *L, int idx);
void hg_lua_to_c_LuaTask(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTask(lua_State *L, void *obj, OwnershipPolicy);

// type API for hg::LuaTaskSystem
bool hg_lua_check_LuaTaskSystem_nobind(lua_State *L, int idx);
void hg_lua_to_c_LuaTaskSystem_nobind(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTaskSystem_nobind(lua_State *L, void *obj, OwnershipPolicy);

// type API for std::shared_ptr<hg::LuaTaskSystem>
bool hg_lua_check_LuaTaskSystem(lua_State *L, int idx);
void hg_lua_to_c_LuaTaskSystem(lua_State *L, int idx, void *obj);
int hg_lua_from_c_LuaTaskSystem(lua_State *L, void *obj, OwnershipPolicy);

// type API for FastNoise
bool hg_lua_check_FastNoise(lua_State *L, int idx);
void hg_lua_to_c_FastNoise(lua_State *L, int idx, void *obj);
int hg_lua_from_c_FastNoise(lua_State *L, void *obj, OwnershipPolicy);

/*
	pass the get_c_type_info function from another binding to this function to resolve external types declared in this binding.
	you will need to write a wrapper to cast the type_info * pointer to the correct type if you are using a binding prefix.
	this function returns the number of unresolved external symbols.
*/
size_t hg_lua_link_binding(hg_lua_type_info *(*get_c_type_info)(const char *));

// create the module object and push it onto the stack
int hg_lua_create_harfang(lua_State *L);
// create the module object and register it into the interpreter global table
bool hg_lua_bind_harfang(lua_State *L, const char *symbol);

