// rust wrapper c
#include "wrapper.h"
#include <memory>
#include "vector"

#include "string"

#include "matplot/matplot.h"

#include "matplot/util/common.h"

#include "matplot/util/concepts.h"

#include "matplot/util/geodata.h"

#include "matplot/util/handle_types.h"

#include "matplot/util/type_traits.h"

#include "matplot/backend/backend_interface.h"

#include "matplot/backend/backend_registry.h"

#include "matplot/backend/gnuplot.h"

#include "matplot/core/axes_type.h"

#include "matplot/core/axis_type.h"

#include "matplot/core/figure_type.h"

#include "matplot/axes_objects/bars.h"

#include "matplot/axes_objects/box_chart.h"

#include "matplot/axes_objects/circles.h"

#include "matplot/axes_objects/contours.h"

#include "matplot/axes_objects/error_bar.h"

#include "matplot/axes_objects/filled_area.h"

#include "matplot/axes_objects/function_line.h"

#include "matplot/axes_objects/histogram.h"

#include "matplot/axes_objects/labels.h"

#include "matplot/axes_objects/line.h"

#include "matplot/axes_objects/matrix.h"

#include "matplot/axes_objects/network.h"

#include "matplot/axes_objects/parallel_lines.h"

#include "matplot/axes_objects/stair.h"

#include "matplot/axes_objects/string_function.h"

#include "matplot/axes_objects/surface.h"

#include "matplot/axes_objects/vectors.h"

#include "matplot/freestanding/axes_functions.h"

#include "matplot/freestanding/axes_lim.h"

#include "matplot/freestanding/histcounts.h"

#include "matplot/freestanding/plot.h"

// FABgen output .cpp
// This file is automatically generated, do not modify manually!

#include "fabgen.h"

static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag);
static void *_type_tag_cast(void *in_T0, uint32_t in_type_tag, uint32_t out_type_tag);

struct gen_type_info {
	uint32_t type_tag;
	const char *c_type;
	const char *bound_name;

	bool (*check)(void* p);
	void (*to_c)(void *p, void *out);
	int (*from_c)(void *obj, OwnershipPolicy policy);
};

// return a type info from its type tag
gen_type_info *gen_get_bound_type_info(uint32_t type_tag);
// return a type info from its type name
gen_type_info *gen_get_c_type_info(const char *type);
// returns the typetag of a userdata object, nullptr if not a Fabgen object
uint32_t gen_get_wrapped_object_type_tag(void* p);

// const char * type tag
static uint32_t type_tag_const_char_ptr = 0x682eed33;


// char type tag
static uint32_t type_tag_char = 0x8cfe579f;


// unsigned char type tag
static uint32_t type_tag_unsigned_char = 0x838f8d38;


// int8_t type tag
static uint32_t type_tag_int8_t = 0x1c554140;


// uint8_t type tag
static uint32_t type_tag_uint8_t = 0x8eabc011;


// short type tag
static uint32_t type_tag_short = 0x8f2890a2;


// int16_t type tag
static uint32_t type_tag_int16_t = 0xbfd40c35;


// char16_t type tag
static uint32_t type_tag_char16_t = 0xc19fe7bb;


// uint16_t type tag
static uint32_t type_tag_uint16_t = 0xa32a93d6;


// unsigned short type tag
static uint32_t type_tag_unsigned_short = 0xc795d733;


// int32 type tag
static uint32_t type_tag_int32 = 0xe6bd962d;


// int type tag
static uint32_t type_tag_int = 0x1451dab1;


// int32_t type tag
static uint32_t type_tag_int32_t = 0x12d46c62;


// char32_t type tag
static uint32_t type_tag_char32_t = 0x6c9f87ec;


// size_t type tag
static uint32_t type_tag_size_t = 0x8883767d;


// uint32_t type tag
static uint32_t type_tag_uint32_t = 0xe2af381;


// unsigned int32_t type tag
static uint32_t type_tag_unsigned_int32_t = 0x92364bb7;


// unsigned int type tag
static uint32_t type_tag_unsigned_int = 0x657249f8;


// int64_t type tag
static uint32_t type_tag_int64_t = 0x2187e0e2;


// long type tag
static uint32_t type_tag_long = 0x3b97a968;


// float32 type tag
static uint32_t type_tag_float32 = 0xfd80ed46;


// float type tag
static uint32_t type_tag_float = 0xc9a55e95;


// intptr_t type tag
static uint32_t type_tag_intptr_t = 0xc10d8312;


// unsigned long type tag
static uint32_t type_tag_unsigned_long = 0x34e673cf;


// uint64_t type tag
static uint32_t type_tag_uint64_t = 0x3d797f01;


// double type tag
static uint32_t type_tag_double = 0xdae7f2ef;


// bool type tag
static uint32_t type_tag_bool = 0x55813692;


// std::string type tag
static uint32_t type_tag_string = 0x9ebeb2a9;


// matplot::line_handle type tag
static uint32_t type_tag_line_handle = 0xe5ce7664;

// matplot::vector_1d type tag
static uint32_t type_tag_vector_1d = 0xe6605a74;

// matplot::figure_handle type tag
static uint32_t type_tag_figure_handle = 0xce978557;

// type_tag based cast system
static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag) {
	if (out_type_tag == in_type_tag)
		return true;

	
	return false;
}

static void *_type_tag_cast(void *in_ptr, uint32_t in_type_tag, uint32_t out_type_tag) {
	if (out_type_tag == in_type_tag)
		return in_ptr;

	void *out_ptr = NULL;
	

	return out_ptr;
}

size_t gen_link_binding(gen_type_info *(*get_c_type_info)(const char *type)) {
	size_t unresolved = 0;

	return unresolved;
}

// bind matplot_line_handle methods
void matplot_line_handle_free(matplot_line_handle h){delete (matplot::line_handle*)h;}
// bind matplot_vector_1d methods
void matplot_vector_1d_free(matplot_vector_1d h){delete (matplot::vector_1d*)h;}
// bind matplot_figure_handle methods
void matplot_figure_handle_free(matplot_figure_handle h){delete (matplot::figure_handle*)h;}
matplot_line_handle  matplot_plot(matplot_vector_1d  x ,matplot_vector_1d  y){
	auto ret = matplot::plot(*(matplot::vector_1d*)x,*(matplot::vector_1d*)y);
	auto retPointer = new matplot::line_handle(ret);
return (matplot_line_handle)(retPointer);
}
void matplot_show(matplot_figure_handle  f){
matplot::show(*(matplot::figure_handle*)f);
}
